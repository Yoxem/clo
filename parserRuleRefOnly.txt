let sqrtSum = (int x, int y) -> int {
let x2 = x * x;
let y2 = y * y;
return x2+y2;
}

let pi = 3.14159;
let _2p = (intToFLo 2) *. pi;

let c = if (2 == 2) then 2 else 3;

let aStr = "hello";

let rec fac = (int n)-> int {
    if n == 0 then 1 else (fac (n - 1));};


type student = Student {int id, string name};

let alice = Student {id=20, name="Alice"};

alice.name = "Siobhan";

let customAnd = (@ 'a has age) ('a x, 'a y) => {'a > 'b};

type list 'a = (Cons 'a (List 'a)) | Nil;

import("alifbata.clo"); # 匯入檔案 alifbata #

t of  import :== string -> Option string string
Error("string") | Ok("import aaa")
# 型別構造子統一大寫，型別小寫 #



PROG ::= (STMT | COMMENT | STMT_COMMENT)*
COMMENT ::= # COMMENT_INNER #
COMMENT_INNER ::= [^#]+
STMT ::= (TYPE_DEF | VAR_DEF | SET | EXPR  ) ";"
TYPE_DEF ::= type ID "=" UNION
            | type ID TYPE_VARS+ "=" UNIOM
TYPE_VARS = ' ID
UNION ::= (REC "|" UNION) | REC
REC ::= ID ( TYPES )
TYPES ::= TYPE+
TYPE ::= ID

EXPR ::= if SUB_EXPR then IF_BRANCH else IF_BRANCH | SUB_EXPR
IF_BRANCH ::= EXPR | { BLOCK }
SUB_EXPR ::= COMPAREE| COMPAREE (LE|GE|LT|GT|EQ|NE) EXPR
COMPAREE ::= FAC| (FAC(ADD | SUB) FAC)
FAC ::= APPLY | (APPLIER (MUL | DIV) APPLY)
APPLY ::= "(" ID APPLYEE* ")" | APPLYEE
APPLYEE ::= REF | CONST | EXPR | FUNC
* CONST ::= INT | STR | FLO | BOOL
BOOL ::= "true" | "false"
FUNC ::= FUNC_OPTION? ( ARGS? ) -> TYPE {BLOCK}
BLOCK ::= PROG (return ID |noReturn) ; 

REF ::= VAR "." ID | VAR
VAR ::= ID
VAR_DEF  ::= "let" VAR "=" EXPR
SET ::= VAR "=" EXPR
FUNC_OPTION ::= ( @ TYPE_HAS (, TYPE_HAS)* )
TYPE_HAS ::= TYPE_VAR "has" ID